{
  "name": "geofire",
  "description": "Location-based querying and filtering using Firebase",
  "version": "3.2.2",
  "author": {
    "name": "Firebase",
    "email": "support@firebase.com",
    "url": "https://www.firebase.com/"
  },
  "homepage": "https://github.com/firebase/geofire-js/",
  "repository": {
    "type": "git",
    "url": "https://github.com/firebase/geofire-js.git"
  },
  "bugs": {
    "url": "https://github.com/firebase/geofire-js/issues"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "http://firebase.mit-license.org/"
    }
  ],
  "keywords": [
    "geoquery",
    "location",
    "firebase",
    "realtime",
    "geolocation"
  ],
  "main": "dist/geofire.js",
  "files": [
    "dist/**",
    "LICENSE",
    "README.md",
    "package.json"
  ],
  "dependencies": {
    "firebase": "2.2.x",
    "rsvp": "3.0.x"
  },
  "devDependencies": {
    "gulp": "3.8.10",
    "gulp-concat": "2.4.3",
    "gulp-ext-replace": "0.1.0",
    "gulp-jshint": "1.9.0",
    "gulp-karma": "0.0.4",
    "gulp-uglify": "1.1.0",
    "jshint-stylish": "1.0.0",
    "streamqueue": "0.1.1",
    "coveralls": "2.11.2",
    "karma-coverage": "0.2.7",
    "karma-failed-reporter": "0.0.3",
    "karma-jasmine": "0.3.5",
    "karma-phantomjs-launcher": "0.1.4",
    "karma-spec-reporter": "0.0.16"
  },
  "scripts": {
    "test": "gulp test",
    "travis": "gulp --travis"
  },
  "readme": "# GeoFire for JavaScript â€” Realtime location queries with Firebase\n\n[![Build Status](https://travis-ci.org/firebase/geofire-js.svg?branch=master)](https://travis-ci.org/firebase/geofire-js)\n[![Coverage Status](https://img.shields.io/coveralls/firebase/geofire-js.svg?branch=master&style=flat)](https://coveralls.io/r/firebase/geofire-js)\n[![Version](https://badge.fury.io/gh/firebase%2Fgeofire-js.svg)](http://badge.fury.io/gh/firebase%2Fgeofire-js)\n\nGeoFire is an open-source library that allows you to store and query a set of keys based on their\ngeographic location. At its heart, GeoFire simply stores locations with string keys. Its main\nbenefit, however, is the possibility of retrieving only those keys within a given geographic\narea - all in realtime.\n\nGeoFire uses [Firebase](https://www.firebase.com/?utm_source=geofire-js) for data storage, allowing\nquery results to be updated in realtime as they change. GeoFire *selectively loads only the data\nnear certain locations, keeping your applications light and responsive*, even with extremely large\ndatasets.\n\nA compatible GeoFire client is also available for [Objective-C](https://github.com/firebase/geofire-objc)\nand [Java](https://github.com/firebase/geofire-java).\n\n### Integrating GeoFire with your data\n\nGeoFire is designed as a lightweight add-on to Firebase. To keep things simple, GeoFire stores data\nin its own format and its own location within your Firebase. This allows your existing data format\nand security rules to remain unchanged while still providing you with an easy solution for geo\nqueries.\n\n### Example Usage\n\nAssume you are building an app to rate bars and you store all information for a bar, e.g. name,\nbusiness hours and price range, at `/bars/<bar-id>`. Later, you want to add the possibility for\nusers to search for bars in their vicinity. This is where GeoFire comes in. You can store the\nlocation for each bar using GeoFire, using the bar IDs as GeoFire keys. GeoFire then allows you to\neasily query which bar IDs (the keys) are nearby. To display any additional information about the\nbars, you can load the information for each bar returned by the query at `/bars/<bar-id>`.\n\n\n## Live Demos\n\nTo see GeoFire in action, you can [play around with our fully-featured demo](https://geofire.firebaseapp.com/sfVehicles/index.html). (Drag the purple circle!)\nThis demo maps all of the San Francisco MUNI vehicles within a certain search radius. You can\ndrag around the search radius and see the vehicles update in realtime.\n\n[![SF MUNI Demo Image](./examples/sfVehicles/images/sf-vehicles.png)](https://geofire.firebaseapp.com/sfVehicles/index.html)\n\nYou can find a full list of our demos [here](https://geofire.firebaseapp.com/index.html)\nand view the code for each of them in the [examples directory](./examples/) of this repository.\nThe examples cover some of the common use cases for GeoFire and explain how to protect your data\nusing Security and Firebase Rules.\n\n\n## Upgrading GeoFire\n\n### Upgrading from GeoFire 2.x.x to 3.x.x\n\nGeoFire 3.x has the same API as 2.x but uses a different underlying data structure to store its\nlocation data. If you are currently using 2.x and want to upgrade to 3.x, you must run the\n[GeoFire 3.x migration script](https://github.com/firebase/geofire-js/blob/master/migration/migrateToV3.js)\non your Firebase. This Node.js script only needs to be run one time and should take only a few seconds\nto minutes depending on the size of your data. To run the script, copy the files in this repo's\n`/migration/` folder to your machine and run the following commands:\n\n```bash\n$ npm install           # install local npm dependencies\n$ node migrateToV3.js   # display usage instructions\n```\n\n### Upgrading from GeoFire 3.0.x to 3.1.x\n\nWith the release of GeoFire 3.1.0, this library now uses [the new query functionality found in\nFirebase 2.0.0](https://www.firebase.com/blog/2014-11-04-firebase-realtime-queries.html). As a\nresult, you will need to upgrade to Firebase 2.x.x and add a new `.indexOn` rule to your Security\nand Firebase Rules to get the best performance. You can view [the updated rules here](./examples/securityRules/rules.json)\nand [read our docs for more information about indexing your data](https://www.firebase.com/docs/security/guide/indexing-data.html).\n\n\n## Downloading GeoFire\n\nIn order to use GeoFire in your project, you need to include the following files in your HTML:\n\n```html\n<!-- RSVP -->\n<script src=\"rsvp.min.js\"></script>\n\n<!-- Firebase -->\n<script src=\"https://cdn.firebase.com/js/client/2.0.2/firebase.js\"></script>\n\n<!-- GeoFire -->\n<script src=\"https://cdn.firebase.com/libs/geofire/3.2.2/geofire.min.js\"></script>\n```\n\nUse the URL above to download both the minified and non-minified versions of GeoFire from the\nFirebase CDN. You can also download them from the\n[releases page of this GitHub repository](https://github.com/firebase/geofire-js/releases).\n[Firebase](https://www.firebase.com/docs/web/quickstart.html?utm_source=geofire-js) and\n[RSVP](https://github.com/tildeio/rsvp.js/) can be downloaded directly from their respective websites.\n\nYou can also install GeoFire via npm or Bower and its dependencies will be downloaded automatically:\n\n```bash\n$ npm install geofire --save\n```\n\n```bash\n$ bower install geofire --save\n```\n\n\n## Getting Started with Firebase\n\nGeoFire requires Firebase in order to store location data. You can [sign up here for a free account](https://www.firebase.com/signup/?utm_source=geofire-js).\n\n\n## API Reference\n\n### GeoFire\n\nA `GeoFire` instance is used to read and write geolocation data to your Firebase and to create queries.\n\n#### new GeoFire(firebaseRef)\n\nCreates and returns a new `GeoFire` instance to manage your location data. Data will stored at\nthe location pointed to by `firebaseRef`. Note that this `firebaseRef` can point to anywhere in your Firebase.\n\n```JavaScript\n// Create a Firebase reference where GeoFire will store its information\nvar firebaseRef = new Firebase(\"https://<your-firebase>.firebaseio.com/\");\n\n// Create a GeoFire index\nvar geoFire = new GeoFire(firebaseRef);\n```\n\n#### GeoFire.ref()\n\nReturns the `Firebase` instance used to create this `GeoFire` instance.\n\n```JavaScript\nvar firebaseRef = new Firebase(\"https://<your-firebase>.firebaseio.com/\");\nvar geoFire = new GeoFire(firebaseRef);\n\nvar ref = geoFire.ref();  // ref === firebaseRef\n```\n\n#### GeoFire.set(keyOrLocations[, location])\n\nAdds the specified key - location pair(s) to this `GeoFire`. If the provided `keyOrLocations`\nargument is a string, the single `location` will be added. The `keyOrLocations` argument can also\nbe an object containing a mapping between keys and locations allowing you to add several locations\nto GeoFire in one write. It is much more efficient to add several locations at once than to write\neach one individually.\n\nIf any of the provided keys already exist in this `GeoFire`, they will be overwritten with the new\nlocation values. Locations must have the form `[latitude, longitude]`.\n\nReturns a promise which is fulfilled when the new location has been synchronized with the Firebase\nservers.\n\nKeys must be strings and [valid Firebase key\nnames](https://www.firebase.com/docs/web/guide/understanding-data.html#section-creating-references?utm_source=geofire-js).\n\n```JavaScript\ngeoFire.set(\"some_key\", [37.79, -122.41]).then(function() {\n  console.log(\"Provided key has been added to GeoFire\");\n}, function(error) {\n  console.log(\"Error: \" + error);\n});\n```\n\n```JavaScript\ngeoFire.set({\n  \"some_key\": [37.79, -122.41],\n  \"another_key\": [36.98, -122.56]\n}).then(function() {\n  console.log(\"Provided keys have been added to GeoFire\");\n}, function(error) {\n  console.log(\"Error: \" + error);\n});\n```\n\n#### GeoFire.get(key)\n\nFetches the location stored for `key`.\n\nReturns a promise fulfilled with the `location` corresponding to the provided `key`.\nIf `key` does not exist, the returned promise is fulfilled with `null`.\n\n```JavaScript\ngeoFire.get(\"some_key\").then(function(location) {\n  if (location === null) {\n    console.log(\"Provided key is not in GeoFire\");\n  }\n  else {\n    console.log(\"Provided key has a location of \" + location);\n  }\n}, function(error) {\n  console.log(\"Error: \" + error);\n});\n```\n\n#### GeoFire.remove(key)\n\nRemoves the provided `key` from this `GeoFire`. Returns a promise fulfilled when\nthe removal of `key` has been synchronized with the Firebase servers. If the provided\n`key` is not present in this `GeoFire`, the promise will still successfully resolve.\n\nThis is equivalent to calling `set(key, null)` or `set({ <key>: null })`.\n\n```JavaScript\ngeoFire.remove(\"some_key\").then(function() {\n  console.log(\"Provided key has been removed from GeoFire\");\n}, function(error) {\n  console.log(\"Error: \" + error);\n});\n```\n\n#### GeoFire.query(queryCriteria)\n\nCreates and returns a new `GeoQuery` instance with the provided `queryCriteria`.\n\nThe `queryCriteria` describe a circular query and must be an object with the following keys:\n\n* `center` - the center of this query, with the form `[latitude, longitude]`\n* `radius` - the radius, in kilometers, from the center of this query in which to include results\n\n```JavaScript\nvar geoQuery = geoFire.query({\n  center: [10.38, 2.41],\n  radius: 10.5\n});\n```\n\n### GeoQuery\n\nA standing query that tracks a set of keys matching a criteria. A new `GeoQuery` is created every time you call `GeoFire.query()`.\n\n#### GeoQuery.center()\n\nReturns the `location` signifying the center of this query.\n\nThe returned `location` will have the form `[latitude, longitude]`.\n\n```JavaScript\nvar geoQuery = geoFire.query({\n  center: [10.38, 2.41],\n  radius: 10.5\n});\n\nvar center = geoQuery.center();  // center === [10.38, 2.41]\n```\n\n#### GeoQuery.radius()\n\nReturns the `radius` of this query, in kilometers.\n\n```JavaScript\nvar geoQuery = geoFire.query({\n  center: [10.38, 2.41],\n  radius: 10.5\n});\n\nvar radius = geoQuery.radius();  // radius === 10.5\n```\n\n#### GeoQuery.updateCriteria(newQueryCriteria)\n\nUpdates the criteria for this query.\n\n`newQueryCriteria` must be an object containing `center`, `radius`, or both.\n\n```JavaScript\nvar geoQuery = geoFire.query({\n  center: [10.38, 2.41],\n  radius: 10.5\n});\n\nvar center = geoQuery.center();  // center === [10.38, 2.41]\nvar radius = geoQuery.radius();  // radius === 10.5\n\ngeoQuery.updateCriteria({\n  center: [-50.83, 100.19],\n  radius: 5\n});\n\ncenter = geoQuery.center();  // center === [-50.83, 100.19]\nradius = geoQuery.radius();  // radius === 5\n\ngeoQuery.updateCriteria({\n  radius: 7\n});\n\ncenter = geoQuery.center();  // center === [-50.83, 100.19]\nradius = geoQuery.radius();  // radius === 7\n```\n\n#### GeoQuery.on(eventType, callback)\n\nAttaches a `callback` to this query which will be run when the provided `eventType` fires. Valid `eventType` values are `ready`, `key_entered`, `key_exited`, and `key_moved`. The `ready` event `callback` is passed no parameters. All other `callbacks` will be passed three parameters:\n\n1. the location's key\n2. the location's [latitude, longitude] pair\n3. the distance, in kilometers, from the location to this query's center\n\n`ready` fires once when this query's initial state has been loaded from the server.\nThe `ready` event will fire after all other events associated with the loaded data\nhave been triggered. `ready` will fire again once each time `updateQuery()` is called, after all new data is loaded and all other new events have been fired.\n\n`key_entered` fires when a key enters this query. This can happen when a key moves from a location outside of this query to one inside of it or when a key is written to `GeoFire` for the first time and it falls within this query.\n\n`key_exited` fires when a key moves from a location inside of this query to one outside of it. If the key was entirely removed from `GeoFire`, both the location and distance passed to the `callback` will be `null`.\n\n`key_moved` fires when a key which is already in this query moves to another location inside of it.\n\nReturns a `GeoCallbackRegistration` which can be used to cancel the `callback`. You can add as many callbacks as you would like for the same `eventType` by repeatedly calling `on()`. Each one will get called when its corresponding `eventType` fires. Each `callback` must be cancelled individually.\n\n```JavaScript\nvar onReadyRegistration = geoQuery.on(\"ready\", function() {\n  console.log(\"GeoQuery has loaded and fired all other events for initial data\");\n});\n\nvar onKeyEnteredRegistration = geoQuery.on(\"key_entered\", function(key, location, distance) {\n  console.log(key + \" entered query at \" + location + \" (\" + distance + \" km from center)\");\n});\n\nvar onKeyExitedRegistration = geoQuery.on(\"key_exited\", function(key, location, distance) {\n  console.log(key + \" exited query to \" + location + \" (\" + distance + \" km from center)\");\n});\n\nvar onKeyMovedRegistration = geoQuery.on(\"key_moved\", function(key, location, distance) {\n  console.log(key + \" moved within query to \" + location + \" (\" + distance + \" km from center)\");\n});\n```\n\n#### GeoQuery.cancel()\n\nTerminates this query so that it no longer sends location updates. All callbacks attached to this query via `on()` will be cancelled. This query can no longer be used in the future.\n\n```JavaScript\n// This example stops listening for all key events in the query once the\n// first key leaves the query\n\nvar onKeyEnteredRegistration = geoQuery.on(\"key_entered\", function(key, location, distance) {\n  console.log(key + \" entered query at \" + location + \" (\" + distance + \" km from center)\");\n});\n\nvar onKeyExitedRegistration = geoQuery.on(\"key_exited\", function(key, location, distance) {\n  console.log(key + \" exited query to \" + location + \" (\" + distance + \" km from center)\");\n\n  // Cancel all of the query's callbacks\n  geoQuery.cancel();\n});\n```\n\n### GeoCallbackRegistration\n\nAn event registration which is used to cancel a `GeoQuery.on()` callback when it is no longer needed. A new `GeoCallbackRegistration` is returned every time you call `GeoQuery.on()`.\n\nThese are useful when you want to stop firing a callback for a certain `eventType` but do not want to cancel all of the query's event callbacks.\n\n#### GeoCallbackRegistration.cancel()\n\nCancels this callback registration so that it no longer fires its callback. This has no effect on any other callback registrations you may have created.\n\n```JavaScript\n// This example stops listening for new keys entering the query once the\n// first key leaves the query\n\nvar onKeyEnteredRegistration = geoQuery.on(\"key_entered\", function(key, location, distance) {\n  console.log(key + \" entered query at \" + location + \" (\" + distance + \" km from center)\");\n});\n\nvar onKeyExitedRegistration = geoQuery.on(\"key_exited\", function(key, location, distance) {\n  console.log(key + \" exited query to \" + location + \" (\" + distance + \" km from center)\");\n\n  // Cancel the \"key_entered\" callback\n  onKeyEnteredRegistration.cancel();\n});\n```\n\n### Helper Methods\n\n#### GeoFire.distance(location1, location2)\n\nStatic helper method which returns the distance, in kilometers, between `location1` and `location2`.\n\n`location1` and `location1` must have the form `[latitude, longitude]`.\n\n```JavaScript\nvar location1 = [10.3, -55.3];\nvar location2 = [-78.3, 105.6];\n\nvar distance = GeoFire.distance(location1, location2);  // distance === 12378.536597423461\n```\n\n\n## Promises\n\nGeoFire uses promises when writing and retrieving data. Promises represent the result of a potentially long-running operation and allow code to run asynchronously. Upon completion of the operation, the promise will be \"resolved\" / \"fulfilled\" with the operation's result. This result will be passed to the function defined in the promise's `then()` method.\n\nGeoFire uses the lightweight RSVP.js library to provide an implementation of JavaScript promises. If you are unfamiliar with promises, please refer to the [RSVP.js documentation](https://github.com/tildeio/rsvp.js/). Here is a quick example of how to consume a promise:\n\n```JavaScript\npromise.then(function(result) {\n  console.log(\"Promise was successfully resolved with the following value: \" + result);\n}, function(error) {\n  console.log(\"Promise was rejected with the following error: \" + error);\n})\n```\n\n\n## Contributing\n\nIf you'd like to contribute to GeoFire, you'll need to run the following commands to get your environment set up:\n\n```bash\n$ git clone https://github.com/firebase/geofire-js.git\n$ cd geofire-js         # go to the geofire directory\n$ npm install -g gulp   # globally install gulp task runner\n$ npm install -g bower  # globally install Bower package manager\n$ npm install           # install local npm build / test dependencies\n$ bower install         # install local JavaScript dependencies\n$ gulp watch            # watch for source file changes\n```\n\n`gulp watch` will watch for changes in the `/src/` directory and lint, concatenate, and minify the source files when a change occurs. The output files - `geofire.js` and `geofire.min.js` - are written to the `/dist/` directory.\n\nYou can run the test suite by navigating to `file:///path/to/geofire-js/tests/index.html` or via the command line using `gulp test`.\n",
  "readmeFilename": "README.md",
  "_id": "geofire@3.2.2",
  "dist": {
    "shasum": "eec462c853926aad34af5fddc5503fd5c36eb7a6"
  },
  "_from": "geofire@",
  "_resolved": "https://registry.npmjs.org/geofire/-/geofire-3.2.2.tgz"
}
